<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Blender Scene</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
    }

    /* Watermark */
    #watermark {
      position: fixed;
      bottom: 16px;
      right: 16px;
      width: 300px;
      opacity: 0.5;
      pointer-events: none;
      z-index: 10;
      background-color: white;
      padding: 8px;
      border-radius: 8px;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>


<img
  id="watermark"
  src="https://pastquestionsbank.com/assets/img/logo1e.png"
  alt="Watermark"
/>


<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  const scene = new THREE.Scene();
  scene.add(new THREE.AxesHelper(5));

  // Blender world background
  const bgColor = new THREE.Color(0.6113813519477844, 0.6113813519477844, 0.6113813519477844);
  const bgStrength = 0.5;

  // Set scene background color multiplied by strength
  scene.background = new THREE.Color(
    bgColor.r * bgStrength,
    bgColor.g * bgStrength,
    bgColor.b * bgStrength
  );

  // Optional: Add hemisphere light to simulate GI from world strength
  const hemiLight = new THREE.HemisphereLight(bgColor, 0x000000, bgStrength);
  scene.add(hemiLight);


  // Ambient light from Blender World
  const ambientLight = new THREE.AmbientLight(
    new THREE.Color(0.6113813519477844, 0.6113813519477844, 0.6113813519477844),
    0.5
  );
  scene.add(ambientLight);

  const camera = new THREE.PerspectiveCamera(26.99147, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(-1.29084, 2.80354, 7.39389);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  controls.target.set(0.00000, 1.09237, -0.37471);
  controls.update();

let faceCameraObj = null;

const loader = new GLTFLoader();
loader.load('scene.gltf', (gltf) => {
  const model = gltf.scene;

  // Make materials double-sided + find Face_Camera
  model.traverse((obj) => {
    if (obj.isMesh && obj.material) {
      obj.material.side = THREE.DoubleSide;
      obj.material.needsUpdate = true;
    }

    if (obj.name === "Face_Camera") {
      faceCameraObj = obj;
    }
  });

  scene.add(model);

  // Get camera from GLTF if exists
  let gltfCameraNode = null;
  gltf.scene.traverse((obj) => {
    if (obj.isCamera) gltfCameraNode = obj;
  });

  if (gltfCameraNode) {
    // Copy position and rotation
    camera.position.copy(gltfCameraNode.position);
    camera.rotation.copy(gltfCameraNode.rotation);

    // Apply perspective properties from gltf.cameras
    const camDef = gltf.parser.json.cameras.find(
      c => c.name === gltfCameraNode.name
    );

    if (camDef && camDef.type === 'perspective') {
      camera.fov = THREE.MathUtils.radToDeg(camDef.perspective.yfov);
      camera.aspect = camDef.perspective.aspectRatio;
      camera.near = camDef.perspective.znear;
      camera.far = camDef.perspective.zfar;
      camera.updateProjectionMatrix();
    }

    // Update OrbitControls
    controls.update();
  }
});

  function animate() {
    requestAnimationFrame(animate);

    if (faceCameraObj) {
      faceCameraObj.lookAt(camera.position);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });
</script>

</body>
</html>
